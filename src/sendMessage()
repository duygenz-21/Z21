async function sendMessage() {
    let text = userInput.value.trim();
    if (!text && !currentFileContent && pendingVisionImages.length === 0) return;

    // 1. TƒÉng bi·∫øn ƒë·∫øm c·ªông d·ªìn
    messageCounter++;
    localStorage.setItem('security_msg_counter', messageCounter.toString());

    // 2. LOGIC CHECK GI√ÉN C√ÅCH (X√≥a s·∫°ch ƒëo·∫°n c≈©, d√°n ƒëo·∫°n n√†y v√†o)
    if (messageCounter >= securityState.nextCheckAt) {      
        
        // G·ªçi h√†m ki·ªÉm tra ng·∫ßm License v·ªõi Server
        performSilentSecurityCheck();

        // T√≠nh to√°n m·ªëc ti·∫øp theo theo c·∫•p s·ªë c·ªông (V√≠ d·ª•: +5, +10, +15...)
        securityState.currentGap += 5; 
        securityState.nextCheckAt = messageCounter + securityState.currentGap;

        // L∆∞u tr·∫°ng th√°i ƒë·ªÉ khi F5 kh√¥ng b·ªã reset l·∫°i m·ªëc check
        localStorage.setItem('sec_next_check', securityState.nextCheckAt.toString());
        localStorage.setItem('sec_current_gap', securityState.currentGap.toString());
        
        console.log(`üïµÔ∏è Security: L·∫ßn check t·ªõi t·∫°i tin th·ª© ${securityState.nextCheckAt}`);
    }

    // Check License
    let featureType = 'chat';
    if (window.isDebateMode) featureType = 'debate';
    else if (window.isSynthesisMode) featureType = 'synthesis';
    else if (pendingVisionImages.length > 0) featureType = 'vision';
    else if (config.isSquadMode) featureType = 'squad';

    const permission = checkFeaturePermission(featureType);
    if (!permission.allowed) {
        alert(permission.message);
        return; 
    }

    // Routing
    if (window.isDebateMode) {
        startDebateSystem(text);
        return;
    }
    if (window.isSynthesisMode) {
        startSynthesisSystem(text);
        return;
    }
    
    userInput.value = "";
    userInput.style.height = 'auto';
    setGeneratingState(true);
    let displayHtml = text;

    // Vision Mode
    if (pendingVisionImages.length > 0) {
        displayHtml += `<br><span class="text-xs text-yellow-400">[Ch·∫ø ƒë·ªô: AI Agent Ph√¢n t√≠ch ·∫£nh]</span>`;
        displayHtml += `<div class="flex gap-2 mt-2 overflow-x-auto">`;
        pendingVisionImages.forEach(img => {
            displayHtml += `<img src="${img}" class="h-12 w-auto rounded border border-slate-600">`;
        });
        displayHtml += `</div>`;
        appendUserMessage(text, displayHtml);
    
        const mainModel = config.models[0];
        const visionModel = config.visionModel;
        const responseGroup = createResponseGroup();
    
        const statusId = createAiCard(responseGroup, "System Agent");
        const updateStatus = (msg) => {
            const el = document.getElementById(statusId);
            if(el) el.innerHTML = `<i class="fas fa-cog fa-spin text-yellow-400"></i> ${msg}`;
        };
    
        try {
            updateStatus("AI ƒëang ph√¢n t√≠ch c√¢u h·ªèi ƒë·ªÉ ch·ªâ ƒë·∫°o Vision...");
            const directorPrompt = `
            B·∫°n l√† m·ªôt tr·ª£ l√Ω AI th√¥ng minh (Director).
            Ng∆∞·ªùi d√πng v·ª´a g·ª≠i m·ªôt h√¨nh ·∫£nh k√®m c√¢u h·ªèi: "${text || 'H√£y ph√¢n t√≠ch ·∫£nh n√†y'}".
            Nhi·ªám v·ª•: H√£y vi·∫øt m·ªôt c√¢u l·ªánh (Prompt) th·∫≠t c·ª• th·ªÉ v√† tr∆∞·ªõc c√¢u h·ªèi nh·ªõ th√™m c·ª•m t·ª´ "h√£y ph√¢n t√≠ch h√¨nh ·∫£nh " ƒë·ªÉ AI b√™n ngo√†i tr·∫£ l·ªùi v√† b·∫°n s∆∞u t·∫≠p c√¢u tr·∫£ l·ªùi cho kh·ªõp v·ªõi √Ω c·ªßa t√¥i nh√© v√† ph·∫£i r√µ r√†ng b·∫±ng ti·∫øng Anh g·ª≠i cho AI Vision ƒë·ªÉ n√≥ tr√≠ch xu·∫•t th√¥ng tin c·∫ßn thi·∫øt nh·∫•t t·ª´ ·∫£nh.
            Ch·ªâ tr·∫£ v·ªÅ n·ªôi dung c√¢u l·ªánh (Prompt).`;
            
            const visionInstruction = await runSingleDebateTurn(mainModel, [{role: "user", content: directorPrompt}], statusId);
            if(abortControllers.length === 0) throw new Error("ƒê√£ d·ª´ng b·ªüi ng∆∞·ªùi d√πng.");
    
            updateStatus(`Vision ƒëang soi ·∫£nh...`);
            const visionContent = [
                { type: "text", text: visionInstruction },
                ...pendingVisionImages.map(img => ({ type: "image_url", image_url: { url: img } }))
            ];
            const visionAnalysis = await runSingleDebateTurn(visionModel, [{role: "user", content: visionContent}], statusId);
            if(abortControllers.length === 0) throw new Error("ƒê√£ d·ª´ng b·ªüi ng∆∞·ªùi d√πng.");
    
            updateStatus("AI ƒëang t·ªïng h·ª£p c√¢u tr·∫£ l·ªùi cu·ªëi c√πng...");
            
            const statusCard = document.getElementById(statusId).closest('.ai-card');
            if(statusCard) statusCard.remove();
    
            const finalPrompt = `
            Th√¥ng tin g·ªëc t·ª´ ng∆∞·ªùi d√πng: "${text}"
            K·∫øt qu·∫£ ph√¢n t√≠ch h√¨nh ·∫£nh t·ª´ Vision AI: """${visionAnalysis}"""
            D·ª±a v√†o th√¥ng tin tr√™n, h√£y tr·∫£ l·ªùi c√¢u h·ªèi c·ªßa ng∆∞·ªùi d√πng.`;
    
            await runStream(mainModel, [...chatHistory, {role: "user", content: finalPrompt}], responseGroup);
    
        } catch (e) {
            console.error("L·ªói Vision:", e);
            let el = document.getElementById(statusId);
            if (!el) appendUserMessage("System Error", `<span class="text-red-400">L·ªói quy tr√¨nh: ${e.message}</span>`);
            else el.innerHTML = `<span class="text-red-400">L·ªói: ${e.message}</span>`;
        }
        setGeneratingState(false);
        return; 
    }

    // Chat / RAG Mode
    let finalContext = null;
    if (currentFileContent) {
        if (currentFileContent.length > 5000) {
            const smartKeywords = await extractSmartKeywords(text, config.models[0]);
            finalContext = await getRelevantContextWithStatus(smartKeywords, currentFileContent);
            displayHtml += `<div class="mt-2 text-[10px] text-blue-400 bg-slate-800/50 p-2 rounded border border-blue-500/30">
                <div class="font-bold text-yellow-400 mb-1"><i class="fas fa-search"></i> SMART RAG Active:</div>
                <div class="italic opacity-80">${smartKeywords}</div>
            </div>`;
        } else {
            finalContext = currentFileContent;
            displayHtml += `<div class="mt-2 text-[10px] text-slate-500">${currentFileName} (Full Scan)</div>`;
        }
    }
    
        // --- [NEW] LOGIC X·ª¨ L√ù C·∫§U TR√öC (Mindmap/Chart) ---
    const structureSelect = document.getElementById('structureSelector');
    const selectedStructure = structureSelect ? structureSelect.value : 'auto';
    let structureInstruction = "";

    if (selectedStructure !== 'auto') {
        if (selectedStructure === 'freeplane') {
             structureInstruction = `
             \n[SYSTEM: FORMAT REQUIREMENTS]
             User wants to export this to Freeplane/Mindmanager.
             1. Use strict Markdown Headings (#, ##, ###) for hierarchy.
             2. Use Bullet points (-) for leaf nodes.
             3. Keep content concise and structured.`;
        } else {
            structureInstruction = `
            \n[SYSTEM: VISUALIZATION REQUIRED]
            User explicitly requests a **${selectedStructure.toUpperCase()}** using Mermaid.js.
            1. Output a SINGLE valid Mermaid code block: \`\`\`mermaid ... \`\`\`
            2. Do NOT explain the syntax, just draw it.
            
            Mapping:
            - "mindmap" -> mermaid mindmap
            - "flowchart" -> mermaid graph TD
            - "timeline" -> mermaid timeline
            - "fishbone" -> mermaid mindmap (spine structure)
            - "matrix" -> mermaid quadrantChart
            - "org" -> mermaid graph TD (subgraphs)
            `;
        }
    }

    // [EDIT] Gh√©p v√†o fullPrompt
    let fullPrompt = text;
    if (finalContext) fullPrompt = `=== CONTEXT ===\n${finalContext}\n=== END ===\n\nUSER: ${text} ${structureInstruction}`;
    else fullPrompt = `${text} ${structureInstruction}`;  
    
    appendUserMessage(text, displayHtml);
    chatHistory.push({ role: "user", content: fullPrompt });
    saveSmartState();
    if(chatHistory.length > 8) chatHistory = [chatHistory[0], ...chatHistory.slice(-7)];
 
    const responseGroup = createResponseGroup();
    abortControllers = [];
 
    let activeModel = config.isSquadMode ? config.models : [config.models[0]];
    let modelsToRun = Array.isArray(activeModel) ? activeModel : [activeModel];
 
    const promises = modelsToRun.map(model => runStream(model, chatHistory, responseGroup));
    await Promise.allSettled(promises);
    setGeneratingState(false);
    renderHeaderStatus();
}